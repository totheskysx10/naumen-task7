### Найденные ошибки ###
- Не вижу смысла в валидации покупки в ShoppingService. Мы уже при добавлении товара проверяем, можно ли такое количество положить в корзину. У корзины есть конструктор, куда передаётся только покупатель, т.е. создать корзину сразу с товаром мы не можем (что логично), а значит до покупки (как и до метода её валидации) мы просто не дойдём. В этой же ситуации встаёт вопрос о целесообразности BuyException
- При покупке не обрабатывается ситуация, когда корзина - null. Без корзины (и соотв-но товара) совершить покупку не должно быть возможным (написан тест на проверку этой ситуации)
- В теории, можно сделать реализацию, где есть возможность совершать покупку не только всей корзиной, но и каким-то одним товаром. А в таком случае метод валидации в ShoppingService будет иметь смысл :)
- При получении корзины не проверяется случай, когда покупатель - null. По-хорошему, корзина не должна быть ничьей (написан тест на проверку этой ситуации)
- Не обрабатывается ситуация, когда при поиске товара по имени прилетает null - товар не найден (написан тест на проверку этой ситуации)
- Не обрабатывается попытка добавить отрицательное или нулевое количество товара
- Нет возможности добавить и купить не целое кол-во товара (пример из реальной жизни - половина арбуза), так как count в product имеет тип int, ровно как и методы добавления/вычета
- После покупки корзина не очищается - так быть не должно, ведь покупатель товар купил и унёс с собой
- Нельзя купить весь товар :) В валидации корзины кидается исключение даже если в корзину положили всё количество, но не более, т.е. логически такая покупка возможна. Кстати в сервисе в методе валидации такого нет)
- Метод getCart(), возможно, лучше назвать takeCart() - ведь мы не получаем корзину для покупателя, а создаём новый объект, т.е. когда покупатель взял пустую корзину (повторно отмечу что создать объект корзины с товарами нельзя - и это правильно)
- Возможно, стоит сделать, чтобы при вызове метода сохранения в ProductDao возвращалось boolean, чтобы была возможность отследить и проверить, что товар в БД сохранился, и сохранился именно нужный нам (тест написан с учётом этого. Хоть мы в этом задании и мокаем Dao, всё равно такой вариант звучит более логично и позволяет лучше протестировать функционал при необходимости)
- В классе продукта при вычете количества товаров используется addCount(-count). Не совсем понимаю вычет через добавление, ведь куда более логично использовать this.count -= count;
- Методы валидации что в Cart, что в ShoppingService статические